<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqinh2s&#39; blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://liuqinh2s.github.io/blog/"/>
  <updated>2021-06-07T03:35:27.453Z</updated>
  <id>https://liuqinh2s.github.io/blog/</id>
  
  <author>
    <name>liuqinh2s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode每日一题：474. 一和零</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/06/leetcode-470-%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/06/leetcode-470-一和零/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2021-06-07T03:35:27.453Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;474-一和零&quot;&gt;&lt;a href=&quot;#474-一和零&quot; class=&quot;headerlink&quot; title=&quot;474. 一和零&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ones-and-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;474. 一和零&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一道动态规划题目。&lt;/p&gt;
&lt;p&gt;首先要明白这是一道背包问题，而且是双维度的，可以装0和1。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：203. 移除链表元素</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/05/leetcode-230-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/05/leetcode-230-移除链表元素/</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2021-06-07T03:21:27.607Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;203-移除链表元素&quot;&gt;&lt;a href=&quot;#203-移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;203. 移除链表元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-linked-list-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;203. 移除链表元素&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;很简单的一道删除单链表节点题&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：160. 相交链表</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/04/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/04/leetcode-160-相交链表/</id>
    <published>2021-06-03T16:00:00.000Z</published>
    <updated>2021-06-04T03:37:28.903Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;160-相交链表&quot;&gt;&lt;a href=&quot;#160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;160. 相交链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;160. 相交链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这题有两种解法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哈希表记录指针&lt;/li&gt;
&lt;li&gt;双指针&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：525. 连续数组</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/03/leetcode-525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/03/leetcode-525-连续数组/</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2021-06-03T02:50:49.723Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;凡是涉及到连续子数组的，都可以用前缀和+哈希表来解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;525-连续数组&quot;&gt;&lt;a href=&quot;#525-连续数组&quot; class=&quot;headerlink&quot; title=&quot;525. 连续数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/contiguous-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;525. 连续数组&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这题要注意的就是，因为要统计元素个数，所以要使用i+1。&lt;/p&gt;
&lt;p&gt;哈希表的key的含义是：当前遍历到的1与符合标准（一半是1）之间的差距，而记录的位置则必须是最小位置。所以只在初始化的时候赋值。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题： 342. 4的幂</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/31/leetcode-342-4%E7%9A%84%E5%B9%82/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/31/leetcode-342-4的幂/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-05-31T05:54:27.123Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个问题看起来是个简单题，其实可以从中学到位运算和一些数学知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;342-4的幂&quot;&gt;&lt;a href=&quot;#342-4的幂&quot; class=&quot;headerlink&quot; title=&quot;342. 4的幂&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-four/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;342. 4的幂&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我自己的解法很简单易懂，但是不够高效：&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode： 560. 和为K的子数组</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/29/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/29/leetcode-560-和为K的子数组/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2021-05-29T06:09:56.796Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这题是在做每日一题中遇到的问题的子问题：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1074. 元素和为目标值的子矩阵数量&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;560-和为K的子数组&quot;&gt;&lt;a href=&quot;#560-和为K的子数组&quot; class=&quot;headerlink&quot; title=&quot;560. 和为K的子数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;560. 和为K的子数组&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;遇到这类问题，首先想的是复杂度，然后复杂度天然是跟问题规模有关的。遍历一遍肯定是必要的，当我们遍历到第n这个位置，我们怎么判断从0到n中有多少个解，进一步的，我们还只要增量数据，n-1的解不应该去重复计算。第n这个位置上的数是一定要考虑进去的，所以我们从后往前寻找。具体代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode： 1074. 元素和为目标值的子矩阵数量</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/29/leetcode-1074-%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/29/leetcode-1074-元素和为目标值的子矩阵数量/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2021-05-29T08:12:59.800Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个问题需要拆分出子问题才好解决，要不然没有思路。它的子问题是：&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;560. 和为K的子数组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1074-元素和为目标值的子矩阵数量&quot;&gt;&lt;a href=&quot;#1074-元素和为目标值的子矩阵数量&quot; class=&quot;headerlink&quot; title=&quot;1074. 元素和为目标值的子矩阵数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1074. 元素和为目标值的子矩阵数量&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;当你理解了子问题之后，我们来想想，怎么把这个问题转换到子问题上呢？也就是如何把二维问题变一维问题呢？&lt;/p&gt;
&lt;p&gt;我们想象把一个矩阵的列上的元素全部加起来，不就是一个一维数组了吗。这个一维数组可以等效的应用在这个问题上。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题： 477. 汉明距离总和</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/28/leetcode-477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/28/leetcode-477-汉明距离总和/</id>
    <published>2021-05-27T16:00:00.000Z</published>
    <updated>2021-05-28T06:01:58.800Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode每日一题是leetcode中文版官方推出的活动，每日一题锻炼解决问题的思维能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;477-汉明距离总和&quot;&gt;&lt;a href=&quot;#477-汉明距离总和&quot; class=&quot;headerlink&quot; title=&quot;477. 汉明距离总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/total-hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;477. 汉明距离总和&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这题初看上去特别简单，就是一个O(n^2)的遍历（组合），对每一组求汉明距离累加起来。不过我一开始就觉得可能会超时，提交后果然超时了。更优的做法是按位遍历，每一位上所有的数要么是0要么是1，把0和1的个数统计出来，相乘，就是这一位的汉明距离总和。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>position sticky</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/28/position-sticky/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/28/position-sticky/</id>
    <published>2021-05-27T16:00:00.000Z</published>
    <updated>2021-05-29T06:11:11.561Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在做公司项目的过程中遇到一个问题：让表头固定，同时其宽度必须占满整个父元素。用fixed，可以固定但是宽度无法撑开。最终用&lt;code&gt;position: sticky&lt;/code&gt;解决了问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;杀了个回马枪，还是说说position:sticky吧« 张鑫旭-鑫空间-鑫生活&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/position&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;position - CSS（层叠样式表） | MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题： 1190. 反转每对括号间的子串</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/27/leetcode-1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/27/leetcode-1190-反转每对括号间的子串/</id>
    <published>2021-05-26T16:00:00.000Z</published>
    <updated>2021-05-27T06:40:57.137Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写之前：&lt;br&gt;2020年整整一年没有写过博客了，沉痛的一年。&lt;br&gt;写博客还是继续下去吧，不管怎样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1190-反转每对括号间的子串&quot;&gt;&lt;a href=&quot;#1190-反转每对括号间的子串&quot; class=&quot;headerlink&quot; title=&quot;1190. 反转每对括号间的子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1190. 反转每对括号间的子串&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这道题一看就知道用栈来解决，但具体到怎么做却依旧不容易想通。直到看过答案后，才发现，实际上真的只需要遍历一遍就能解决问题。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>图灵机</title>
    <link href="https://liuqinh2s.github.io/blog/2019/04/26/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    <id>https://liuqinh2s.github.io/blog/2019/04/26/图灵机/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.478Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图灵机&quot;&gt;&lt;a href=&quot;#图灵机&quot; class=&quot;headerlink&quot; title=&quot;图灵机&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图灵机&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;图灵机（Turing Machine）是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;英国数学家艾伦·图灵&lt;/a&gt; 在1936年发表的 &amp;quot;&lt;a href=&quot;https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;On Computable Numbers, with an Application to the Entscheidungsproblem&lt;/a&gt;&amp;quot;（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。&lt;/p&gt;
&lt;h3 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av30479683?from=search&amp;amp;seid=11735601712045998475&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;妈咪说：图灵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://movie.douban.com/subject/10463953/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模仿游戏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Knowledge of CS" scheme="https://liuqinh2s.github.io/blog/categories/Knowledge-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>冯·诺依曼结构</title>
    <link href="https://liuqinh2s.github.io/blog/2019/04/22/%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84/"/>
    <id>https://liuqinh2s.github.io/blog/2019/04/22/冯·诺依曼结构/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.478Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冯·诺依曼结构&quot;&gt;&lt;a href=&quot;#冯·诺依曼结构&quot; class=&quot;headerlink&quot; title=&quot;冯·诺依曼结构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冯·诺依曼结构&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;冯·诺伊曼结构与 &lt;strong&gt;存储程序型计算机&lt;/strong&gt; 是互相通用的名词&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;哈佛结构&lt;/strong&gt; 是一种将程序数据与普通数据分开存储的设计概念，可以说是冯·诺依曼结构的一种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储程序计算机在体系结构上主要特点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以运算单元为中心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采用存储程序原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;存储器是按地址访问、线性编址的空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制流由指令流产生&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指令由 &lt;strong&gt;操作码&lt;/strong&gt; 和 &lt;strong&gt;地址码&lt;/strong&gt; 组成&lt;/li&gt;
&lt;li&gt;数据以二进制编码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;五个组成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;运算器（算术逻辑单元）&lt;/li&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Knowledge of CS" scheme="https://liuqinh2s.github.io/blog/categories/Knowledge-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是字符集和编码</title>
    <link href="https://liuqinh2s.github.io/blog/2019/04/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/"/>
    <id>https://liuqinh2s.github.io/blog/2019/04/21/什么是字符集和编码/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.478Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;文本文件中，为了让比特表示文字，我们发明了字符集，让特定的比特序列对应特定的字符。&lt;/p&gt;
&lt;p&gt;常见的字符集有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/ASCII&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ASCII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/EASCII&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EASCII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/GB_2312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GB2312&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GBK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh/UTF-8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UTF-8&lt;/a&gt; （严格来说UTF-8只是Unicode的一种编码方式）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/ANSI%E7%BC%96%E7%A0%81&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANSI编码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Knowledge of CS" scheme="https://liuqinh2s.github.io/blog/categories/Knowledge-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机中的信息</title>
    <link href="https://liuqinh2s.github.io/blog/2019/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>https://liuqinh2s.github.io/blog/2019/04/20/计算机中的信息/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.477Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息的本质&quot;&gt;&lt;a href=&quot;#信息的本质&quot; class=&quot;headerlink&quot; title=&quot;信息的本质&quot;&gt;&lt;/a&gt;信息的本质&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;信息的本质是消除不确定性&lt;/strong&gt;：我们抛掷一枚硬币，然后用手盖住，出现正面朝上和反面朝上的概率都是二分之一。当我们偷看了结果，确定了是正面还是反面朝上，也就获得了信息。在这个例子中，我们消除的不确定性是一个二分之一的概率。在 &lt;strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%85%8B%E5%8A%B3%E5%BE%B7%C2%B7%E9%A6%99%E5%86%9C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;香农&lt;/a&gt;&lt;/strong&gt; 划时代的论文 &lt;strong&gt;&lt;a href=&quot;http://math.harvard.edu/~ctm/home/text/others/shannon/entropy/entropy.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通信的数学原理&lt;/a&gt;&lt;/strong&gt; 中，首次提出了信息是可量化的，以及如何量化信息。我们以bit为信息的度量单位，一个bit可以是0或者1，我们每获得一个bit的信息，就会消除一个二分之一的不确定性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小思考题：如果我们抛掷的是一个骰子呢，当我们确定了一次投掷结果，我们获得多少信息（用bit为单位衡量）？&lt;br&gt;我们都知道，骰子有6个面，分别刻有1~6，我们有六分之一的概率得到其中任意一个面朝上。那么我们获得的信息应该是：$\log_2 6$。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Knowledge of CS" scheme="https://liuqinh2s.github.io/blog/categories/Knowledge-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ map的remove函数实现</title>
    <link href="https://liuqinh2s.github.io/blog/2019/04/15/C++%20map%E7%9A%84remove%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
    <id>https://liuqinh2s.github.io/blog/2019/04/15/C++ map的remove函数实现/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.477Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天同学群里面讨论了这样一段代码，说是产品出了bug，现场急着修复。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="https://liuqinh2s.github.io/blog/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo把英文引号渲染成中文引号的问题</title>
    <link href="https://liuqinh2s.github.io/blog/2019/04/15/hexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://liuqinh2s.github.io/blog/2019/04/15/hexo把英文引号渲染成中文引号的问题/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.477Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;其实这个问题我早就发现了，但一直没太在意，今天写博客的时候又看到这个难看的引号，终于忍不住想看看到底出了什么问题。&lt;/p&gt;
&lt;p&gt;首先我试了中文的单引号和英文的单引号，发现渲染效果都一样，然后想看看当我分别打中文单引号和英文单引号的时候，hexo的渲染结果到底是不是一样。&lt;/p&gt;
&lt;p&gt;打开chrome开发工具，发现页面上的英文单引号统一被渲染成了中文的单引号。&lt;/p&gt;
&lt;p&gt;然后我手动修改页面看了下英文单引号是什么样子，发现样式确实很不一样。&lt;/p&gt;
&lt;p&gt;那么问题就确定了：hexo把英文引号渲染成了中文引号。&lt;/p&gt;
    
    </summary>
    
      <category term="Fixed Issues" scheme="https://liuqinh2s.github.io/blog/categories/Fixed-Issues/"/>
    
    
  </entry>
  
  <entry>
    <title>动态数组的分摊分析</title>
    <link href="https://liuqinh2s.github.io/blog/2019/03/03/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90/"/>
    <id>https://liuqinh2s.github.io/blog/2019/03/03/动态数组的分摊分析/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.476Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;动态数组在每次容量用尽时，重新申请2倍于当前数组的空间，并将原数组中的内容拷贝到新的空间，然后释放原数组的内存空间。对于动态数组，每次插入的花费有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容量够用，我们只需要存储新的元素&lt;/li&gt;
&lt;li&gt;容量不够用，创建新的空间，拷贝原数组进新的空间，再存储这个新的元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析方法有许多，统称为：amortized analysis（分摊分析）&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://liuqinh2s.github.io/blog/2019/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://liuqinh2s.github.io/blog/2019/02/19/快速排序/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.476Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：&lt;strong&gt;选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边&lt;/strong&gt;。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition操作。&lt;/p&gt;
&lt;p&gt;在使用partition操作的前提下，递归解决问题就OK了。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://liuqinh2s.github.io/blog/2019/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://liuqinh2s.github.io/blog/2019/01/19/并查集/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.475Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;h3 id=&quot;什么是并查集&quot;&gt;&lt;a href=&quot;#什么是并查集&quot; class=&quot;headerlink&quot; title=&quot;什么是并查集&quot;&gt;&lt;/a&gt;什么是并查集&lt;/h3&gt;&lt;p&gt;并查集的核心是&lt;code&gt;parent&lt;/code&gt;指针，一个结点可以找到自己所属的结点。从而把结点&lt;strong&gt;归类&lt;/strong&gt;。有两个核心操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Union（用来合并两个并查集）&lt;/li&gt;
&lt;li&gt;Find（用于查找一个结点的&lt;code&gt;parent&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以并查集可以叫做：union-find data structure。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://liuqinh2s.github.io/blog/2019/01/17/KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://liuqinh2s.github.io/blog/2019/01/17/KMP算法/</id>
    <published>2019-01-16T16:00:00.000Z</published>
    <updated>2021-05-27T06:00:42.473Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;p&gt;KMP算法用来在一个文本中查找模式串，如下图所示：&lt;/p&gt;
&lt;p&gt;文本匹配例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0ceea57.jpg#align=left&amp;amp;display=inline&amp;amp;height=78&amp;amp;linkTarget=_blank&amp;amp;originHeight=78&amp;amp;originWidth=392&amp;amp;width=392&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们把上面那个长字符串的称为&lt;strong&gt;文本&lt;/strong&gt;，下面这个短的称为&lt;strong&gt;模式串&lt;/strong&gt;。我们的目的是查看&lt;code&gt;ABADABAD&lt;/code&gt;是否出现在文本中。&lt;/p&gt;
&lt;p&gt;不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0d27686.jpg#align=left&amp;amp;display=inline&amp;amp;height=100&amp;amp;linkTarget=_blank&amp;amp;originHeight=100&amp;amp;originWidth=418&amp;amp;width=418&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;跳过不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0cf058c.jpg#align=left&amp;amp;display=inline&amp;amp;height=90&amp;amp;linkTarget=_blank&amp;amp;originHeight=90&amp;amp;originWidth=410&amp;amp;width=410&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;KMP算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的&lt;code&gt;ABA&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
    
  </entry>
  
</feed>
